<div>
	<!--title:Модели даних. Массивы-->
	<!--keywords:Массивы;-->
	<div class="title">
		<h1>
			Робота с масивами
		</h1>
		<div class="breadcrumb">
			<a href="index">Модели даних</a>
		</div>
	</div>
	<p>
		Массив може быть как самостоятельным елементом моделі (тогда у нього есть ім'я і он буде отображен в корне моделі),
		так и дочерним елементом какого або другого об'єкта.
	</p>
	<p>Массив визначається типом <code>Array</code> (либо <code>LazyArray</code> для "ленивого" масива) в дескрипторе (первое поле) набора даних.</p>


	<div class="info tip">
		Зверніть увагу! Не следует використовувати массивы со слишком большим количеством елементів.
		Кроме того, що це приводит к падению быстродії, с этим еще и очень неудобно работать конечному користувачу.
		Для роботи с большими масивами (таблицами) используйте серверную сортировку, фильтрацию и разбиение на страницы.
		<a href="paging">Детальніше...</a>.
		<br />
		<br />
		Рекомендуемый размер масива на клиенте - не более 100 елементів. Максимальный, который не приводит к заметному уменьшению производительности - около 200 елементів.
	</div>

	<h3>Обычные массивы</h3>
	<p>
		Это просто набор даних. Кожна строка набора буде соответствующим об'єктом масива. Тип об'єкта визначається дескриптором
		набора.
	</p>

	<h5>Приклад</h5>
	<p>

		Нехай маєся фрагмент кода SQL:

<pre class="code-highlight js" data-lang="sql">
<script type="text/template">
select [Agents!TAgent!Array] = null, [Id!!Id] = Id, [Name!!Name] = Name, Code
from dbo.Agents where ....;
</script>
</pre>

		Он сформирует в корне моделі массив <code>Agents</code>. Каждый елемент масива буде иметь тип
		<code>TAgent</code> со следующими властивостіми: <code>Id</code>, <code>Name</code>, <code>Code</code>.
	</p>


	<h3>Дочерние массивы</h3>
	<p>
		Дочерний массив всегда является вложенным и являє собою властивість другого об'єкта. Как правило не має имени.
		В родительском об'єкте повинно бути властивість-заполнитель со значенням <code>null</code> и типом елементів дочірнього масива.
		Зверніть увагу, что дочерний набор повинен обрабатываться после основного.
	</p>
	<p>
		Для того, щоб связать массив с родительским об'єктом, в наборе даних обов'язково должно присутствовать
		поле со ссылкой на родительский об`єкт у вигляді <code>[Name!ParentType.PropertyName!ParentId]</code>, где
		<ul class="params">
			<li><b>[Name]</b> - необов'язковое ім'яполя. Може бути пустым.</li>
			<li><b>ParentType.PropertyName</b> - Им'я типа и ім'я властивості батьківського об'єкта, куда буде записан елемент масива.</li>
			<li><b>ParentId</b> - модификатор поля.</li>
		</ul>
	</p>
	<p>
		Связывание работает наступним чином:
		<ol>
			<li>Берется значення поля <code>!ParentId</code>.</li>
			<li>
				В моделі ищется об`єкт с типом <code>ParentType</code>
				с соответствующим идентификатором (само собой разумеется, що цет идентификатор повинен быть помечен модификатором <code>!Id</code>).
			</li>
			<li>В найденном об'єкте ищется поле с именем <code>PropertyName</code>. В массив, відповідний этому полю добавляется елемент.</li>
		</ol>
	</p>

	<h5>Приклад</h5>
	<p>

		Нехай маєся фрагмент кода SQL:

<pre class="code-highlight js" data-lang="sql">
<script type="text/template">
/*основної об'єкт*/
select [Document!TDocument!Object] = null, [Id!!Id] = Id, [Date], [Rows!TRow!Array]=null
from dbo.Documents where ....;

/*дочерний массив*/
select [!TRow!Array] = null, [Id!!Id] = Id, [Qty], [Price], [Sum], [!TDocument.Rows!ParentId]=null
from dbo.DocDetails where ....;
</script>
</pre>

		Он сформирует в корне об`єкт <code>Document</code> типа
		<code>TDocument</code> со следующими властивостіми: <code>Id</code>, <code>Date</code>, <code>Rows</code>.
		Властивість <code>Rows</code> буде представлять собой массив елементів типа <code>TRow</code> со следующими властивостіми:
		<code>Id</code>, <code>Qty</code>, <code>Price</code>, <code>Sum</code>.
	</p>


	<h3>"Ленивые" массивы</h3>

	<p>
		Ленивые (on demand) массивы не добавляются в модель в процессе , а загружаются при первом обращении к властивості.
		Частіше за все этот механизм використовується у випадку, якщо основная модель являє собою массив, а дочерние массивы
		будуть нужны не всегда, а тільки при попытке их отобразить. Типичный пример - список контрагентов, каждый з которых
		містить пов'язані с ним документы.
	</p>
	<p>
		Ленивые массивы могут быть тільки дочерними и визначаються модификатором <code>LazyArray</code>.
	</p>
	<div class="tip warning">
		Cледует обратить внимание на то, что структура дочірнього об'єкта (не данные!) повинна быть известна системе
		при начальном построении моделі. Поэтому при использовании "ленивых" массивов, необходимо повернути пустой набор даних,
		который буде определять правильную структуру даних масива. Реальными данными массив заполнится уже в процессе завантаження.
	</div>
	<p>
		Для завантаження ленивого масива буде викликана збережена процедура завантаження моделі з суфіксом, соответствующим имени
		властивості основної моделі. В качестве параметра <code>@Id</code> ей буде передан идентификатор основного елементу.
		Она повинна повернути набор, соответствущий описанию масива в основної моделі. Властивість с
		модификатором <code>!ParentId</code> не обов'язково.
	</p>

	<h5>Приклад</h5>
	<p>

		Нехай маєся список контрагенов со списком документов.

<pre class="code-highlight js" data-lang="sql">
<script type="text/template">
<![CDATA[
/*основная процедура*/
create or alter proceduure dbo.[Agent.Index.Load]
@UserId bigint
as
begin
	set nocount on;
	/* основної набор */
	select [Agents!TAgent!Array] = null, [Id!!Id] = Id, [Name!!Name] = Name, [Code]
		[Documents!TDocument!LazyArray] = null /* ленивый массив Documents */
	from dbo.Agents where ....;

	/* структура об'єкта TDocument - пустой набор */
	select [Documents!TDocument!Array] = null, [Id!!Id] = Id, [Date], [Sum], [Memo]
	from dbo.Documents where 0 <> 0;
end
go

/*процедура завантаження ленивого масива. Суффикс Documents соответствует имени властивості в основної моделі.*/
create or alter procedure dbo.[Agent.Documents]
@UserId bigint,
@Id bigint /*идентификтор контрагента, для якого загружается список документов*/
as
begin
	set nocount on;
	select [Documents!TDocument!Array] = null, [Id!!Id] = Id, [Date], [Sum], [Memo]
	from dbo.Documents where [Agent]=@Id and ....;
end
go
]]>
</script>
</pre>

		Он сформирует в корне об`єкт <code>Document</code> типа
		<code>TDocument</code> со следующими властивостіми: <code>Id</code>, <code>Date</code>, <code>Rows</code>.
		Властивість <code>Rows</code> буде представлять собой массив елементів типа <code>TRow</code> со следующими властивостіми:
		<code>Id</code>, <code>Qty</code>, <code>Price</code>, <code>Sum</code>.
	</p>


	<p>Процедуры завантаження ленивых массивов также могут имет параметри и використовувати <a href="paging">разбиение на страницы</a>.</p>

	<div class="tip info">
		Зверніть увагу! Є можливість обновить (перезавантажити з базы даних) тільки содержимое ленивого масива 
		без основної моделі. Для цього просто передайте массив в качестве аргумента в команду <a class="code-link" href="/xaml/bind/bindcmd">Refresh (Reload)</a> або в метод
		<a class="code-link" href="/client/controller">$reload</a> контроллера.
	</div>
</div>

