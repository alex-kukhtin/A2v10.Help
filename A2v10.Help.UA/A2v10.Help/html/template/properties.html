<div>
	<!--title:Шаблони. Властивості-->
	<!--keywords:properties;Властивості;-->
	<div class="title">
		<h1>
			Шаблони. Властивості
		</h1>
		<div class="breadcrumb">
			<a href="index">Шаблони</a>
		</div>
	</div>

	<p>
		Раздел властивостей дозволяє добавить к елементум моделі додаткові властивості. Они могут быть как скалярными (строка, число), так и
		<i>вычисляемыми.</i>
	</p>

	<p>
		Вычисляемые властивості являють собою мощный механизм, позволяющий сильно упростить реализацию сложной
		бизнес-логики програми. Такое властивість являє собою функцию, яка викликаєся при попытке чтения (или установки) властивості.
		Возвращаемый функцией результат рассматривается как значення властивості.
		При расчетах функция може звертатися до другим вычисляемым властивостім и т.д.
		Таким образом легко строить обработчики зависимых даних без использования моделі событий.
	</p>

	<p>
		Вычисляемые властивості могут как дополнять существующие в моделі статичні властивості, так и заменять существующие.
	</p>

	<p>
		Об'єкт, що описує властивості в шаблоне, является обычным об'єктом JavaScript.
		Імена властивостей этого об'єкта представляют
		собой повне ім'я властивості (включая ім'ятипа об'єкта), а значення - скалярным типом, функцией або об'єктом.
	</p>


	<h3>Синтаксис</h3>
<pre class="code-highlight js">
<script type="text/template">
/* властивості */
properties: {
	'TypeName.property': String | Number | Boolean, /* скалярное властивість */
	'TypeName.property': Function,                  /* вычисляемое властивість */
	'TypeName.property': {                          /* вычисляемое властивість с можливістью установки */
		get: Function,
		set: Function
	}
	...
}
</script>
</pre>
	<h3>Правила именования</h3>

	<p>
		Префикс властивості <code>TypeName</code> повинен совпадать с <i>именем типа</i>, который задається при построении моделі. По соглашению
		імена типов починаються с заглавной буквы "Т" (от слова Type).
	</p>

	<p>
		Якщо вычисляемое властивість має такое же имя, как и властивість в моделі, то оно не добавляется к моделі, а <i>заменяет</i>
		властивість моделі. Это приведет к тому, что вычисленное значення буде сохранено в моделі.
	</p>

	<p>
		Якщо ім'я властивості начинается с символов "$" або "_", то оно является внутренними и не участвует
		в обмене данными между клиентом и сервером. Якщо ім'я властивості начинается с символов "$$" то його
		изменение не изменяет флажок <a class="code-link" href="/client/data">$dirty</a> для моделі.
	</p>

	<h3>Скалярные властивості</h3>
	<p>
		Значенням скалярного властивості всегда является примитивный тип JavaScript, такой как, наприклад <code>String</code>, <code>Number</code>
		или <code>Boolean</code>. В модель буде добавлено властивість соответствующйого типа.
	</p>


	<h3>Вычисляемые властивості</h3>
	<p>
		Значенням вычисляемого властивості является функция, яка буде вычислена при попытке обращения к властивості. Аргумент функции:
		<ul class="params">
			<li><code>this</code> - ссылка на об'єкт, в который добавляется властивість.</li>
		</ul>
		Функция повинна повернути значення властивості.
	</p>
	<p>Функция викликаєся тільки при обращении к властивості. Якщо обращений нет то функция никогда викликатися не буде.</p>
	<p>Обращения к вычисляемым властивостім могут виконуватися многократно и достаточно часто. Никогда не используйте обращение к серверу 
	в коде вычисляемых властивостей. Якщо потрібно - используйте кэширование.</p>

	<p class="tip warning">
		<b>Зверніть увагу!</b> Не используйте стрелочные функции при определении вычисляемых властивостей. Стрелочные функции не имеют
		собственного значення <code>this</code> (вони используют родительский контекст), поэтому получить ссылку на об`єкт буде невозможна.
	</p>


	<h3>Вычисляемые властивості с можливістью установки</h3>
	<p>
		В дополнение к функции чтения властивості (геттер) можна задать и функцию установки (сеттер). Ця функция буде викликана при попытке
		установки значення властивості. Аргументы функции:
		<ul class="params">
			<li><code>this</code> - ссылка на об'єкт, в который добавляется властивість.</li>
			<li><code>value</code> - устанавливаемое значення.</li>
		</ul>
	</p>
	<p>
		Используйте властивості с сеттерами внимательно и осторожно. При этом очень легко получить бескінцеву рекурсию.
	</p>

	<h3>Приклад</h3>
	<p>
		Приклад шаблона документа с вычислением суммы по строке и суммы по документу. 
		Нехай в моделі есть документ со строками, в каждой з которых есть цена и количество.
		Нужно автоматически рассчитывать сумму по строке и сумму по документу.

		<pre class="code-highlight js" data-lang="js">
<script type="text/template">
const template = {
	properties: {
		'TRow.Sum'() {return this.Qty * this.Price }, /*сумма по строке */,
		'TDocument.Sum': getDocumentSum /*сумма по документу */
	}
};

function getDocumentSum() {
	return this.Rows.reduce((prev, curr) => prev + curr.Sum, 0);
}
</script>
</pre>

	</p>
</div>