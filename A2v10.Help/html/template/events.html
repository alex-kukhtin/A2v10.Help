<div>
	<!--title:Шаблони. Події-->
	<!--keywords:events;Події;-->
	<div class="title">
		<h1>
			Шаблони. Події
		</h1>
		<div class="breadcrumb">
			<a href="index">Шаблони</a>
		</div>
	</div>

	<p>
		Об'єкт, що описує события в шаблоне, является обычным об'єктом JavaScript.
		Імена властивостей этого об'єкта являются іменами событий, а значення - функциями, які будуть вызваны при возникновении события.
	</p>

	<p>
		Імена событий конструируются различным образом в залежності від типа события:
		<ul class="std">
			<li>для всей моделі імена фиксированные.</li>
			<li>для события создания об'єкта конструируются з типа об'єкта и суффикса <code class="string">.constuct</code>.</li>
			<li>для событий изменения даних з полного пути к елементу даних и заданного суффикса.</li>
		</ul>
	</p>

	<p>
		Полный шлях до елементу даних фактически являє собою повне ім'я властивості об'єкта, начиная від корня моделі. Для указания
		елементу масива використовується суффикс <code>[]</code>.
	</p>

	<p>
		Синтаксис:
<pre class="code-highlight js" data-lang="js">
<script type="text/template">
const tempate = {
  events: {
    'Model.load': (this: IRoot, root: IRoot, caller?: IRoot): void,
    'Model.unload': (this: IRoot, root: IRoot): void,
    '{Type}.construct': (this: IRoot, elem: IElement, prop?: string): void,
    '{PropertyName}.change': (this: IRoot, elem?: IElement, newVal?: any, oldVal?: any, prop?:string): void,
    '{PropertyName}.changing': (this: IRoot, elem?: IElement, newVal?: any, oldVal?: any, prop?:string): boolean,
    '{ArrayName}.add': (this: IRoot, array?: IArrayElement, elem?:IElement>): void 
  }
}
</script>
</pre>
	</p>

	<h3>Cобытия для всей моделі</h3>
	<p>Эти события имеют фиксированные імена.</p>
	<ul class="std">
		<li><code>Model.load</code> - модель загружена.</li>
		<li><code>Model.unload</code> - модель выгружена. Никакие дії уже невозможны. Частіше за все используюется для отписки 
		от событий глобальной шины событий.</li>
		<li><code>Model.saved</code> - модель сохранена.</li>
		<li><code>Model.beforeSave</code> - перед зберіганням.</li>
	</ul>

	<p>
		Аргументы для событий моделі:
		<ul class="params">
			<li><code>this</code> - корень моделі даних (IRoot).</li>
			<li><code>model</code> - корень моделі даних (IRoot).</li>
			<li>
				<code>caller</code> - ссылка на корень моделі даних (IRoot) вызывающйого об'єкта.
				Например, якщо це модель діалога, то
				<code>caller</code> буде ссылкой на модель, з которой этот діалог был вызван.
				Может використовуватися для взаимодії с вызывающим елементом.
				Для событий <code>Model.saved</code>, <code>Model.save</code> значення всегда буде
				<code>undefined</code>.
			</li>
		</ul>
	</p>

	<h3>Події для об'єктов</h3>
	<ul class="std">
		<li>
			<code>.construct</code> - об`єкт создан.
			Префикс имени события являє собою ім'ятипа об'єкта. В обработчике этого события можна дополнить
			созанный елемент новыми властивостіми. Однако 
			для этого лучше використовувати механизм властивостей (<a class="code-link" href="properties">properites</a>).
		</li>
		<li>
			<code>.change</code> - значення властивості изменено.
			Префикс имени события являє собою полный шлях до властивості в моделі даних.
		</li>
		<li>
			<code>.changing</code> - значення властивості буде изменено.
			Префикс имени события являє собою полный шлях до властивості в моделі даних. 
			Є можливість отменить изменения.
		</li>
	</ul>

	<p>
		Аргументы для события <code>.construct</code>:
		<ul class="params">
			<li><code>this</code> - корень моделі даних (IRoot).</li>
			<li><code>elem</code> - созданный елемент.</li>
			<li><code>prop</code> - ім'я властивості батьківського елементу, которому буде присвоен созданный об'єкт. Имеет 
			смысл для обработчиков создания елементів в <code>MapObject</code>.</li>
		</ul>

		Аргументы для событий <code>.changing</code>, <code>.change</code>:
		<ul class="params">
			<li><code>this</code> - корень моделі даних (IRoot).</li>
			<li><code>elem</code> - елемент.</li>
			<li><code>newValue</code> - новое значення властивості.</li>
			<li><code>oldValue</code> - старое значення властивості.</li>
			<li><code>prop</code> - ім'язменяемого властивості.</li>
		</ul>

		Возвращаемое значення має смысл тільки для события <code>.changing</code>:

		<ul class="params">
			<li>
				<code>Boolean</code> - строгое значення <code>false</code>. Отменяет попытку изменения значення властивості. Любое другое
				значення разрешает изменения.
			</li>
		</ul>

		<div class="tip warning">
			<b>Зверніть увагу!</b> При изменении значений об'єктных властивостей, оба значення властивості (и старое и новое) будуть указывать
			на один и тот-же об'єкт. Это происходит потому, что об`єкт никогда не пресоздается. Просто перезаписываются його властивості.
		</div>
	</p>

	<h3>Події для массивов</h3>
	<p>Префикс имени для всех событий массивов являє собою полный шлях до властивості в моделі.</p>
	<ul class="std">
		<li><code>[].adding</code> - перед добавлением елементу в массив.</li>
		<li><code>[].add</code> - елемент добавлен в массив.</li>
		<li><code>[].change</code> - изменен елемент масива.</li>
		<li><code>[].remove</code> -  елемент удален з масива.</li>
		<li><code>[].select</code> - елемент масива выбран.</li>
	</ul>
	<p class="tip warning">
		<b>Зверніть увагу!</b> Cобытия будуть генерироваться тільки тогда, когда для манипуляции с масивами використовуються средства платформи.
		Якщо массив меняется стандартними методами (наприклад <code>push</code>, <code>splice</code>), то события генерироваться не будуть.
	</p>

	<p>
		Аргументы для событий массивов:
		<ul class="params">
			<li><code>this</code> - корень моделі даних (IRoot).</li>
			<li><code>arr</code> - изменяемый массив.</li>
			<li><code>elem</code> - новый або удаленный елемент.</li>
		</ul>
		Возвращаемое значення має смысл тільки для события <code>.adding</code>.
		<ul class="params">
			<li><code>Boolean</code> - строгое значення <code>false</code>. Отменяет операцию добавления елементу в массив.</li>
		</ul>
	</p>


	<h3>Пользовательские события</h3>
	<p>Описанные выше события являются встроенными. Однако, никто не запрещает використовувати собственные события, які могут более 
	точно описывать бизнес-логику програми.</p>
	<p>
		Такие события генерируются методом <a class="code-link" href="/client/data">$emit</a> кореневого об'єкта (IRoot) и могут иметь 
		произвольное ім'я(конечно не пересекающееся с системными іменами). Методом <code>$emit</code> также можна генерировать 
		и системные события.
	</p>

	<p class="tip warning">
		<b>Зверніть увагу!</b> Модель событий в системе связана с данными, а не с елементуми пользовательского интерфейса.
		Другими словами, события возникают тогда, когда меняются данные. Возникновение событий никак не связано с пользовательским
		интерфейсом. Фактично, пользовательского интерфейса вообще може не быть.
	</p>
</div>