<div>
	<!--title:Шаблоны. Свойства-->
	<!--keywords:properties;Свойства;-->
	<div class="title">
		<h1>
			Шаблоны. Свойства
		</h1>
		<div class="breadcrumb">
			<a href="index">Шаблоны</a>
		</div>
	</div>

	<p>
		Раздел свойств позволяет добавить к элементам модели дополнительные свойства. Они могут быть как скалярными (строка, число), так и
		<i>вычисляемыми.</i>
	</p>

	<p>
		Вычисляемые свойства представляют собой мощный механизм, позволяющий сильно упростить реализацию сложной
		бизнес-логики приложения. Такое свойство представляет собой функцию, которая вызывается при попытке чтения (или установки) свойства.
		Возвращаемый функцией результат рассматривается как значение свойства.
		При расчетах функция может обращаться к другим вычисляемым свойствам и т.д.
		Таким образом легко строить обработчики зависимых данных без использования модели событий.
	</p>

	<p>
		Вычисляемые свойства могут как дополнять существующие в модели статические свойства, так и заменять существующие.
	</p>

	<p>
		Объект, описывающий свойства в шаблоне, является обычным объектом JavaScript.
		Имена свойств этого объекта представляют
		собой полное имя свойства (включая имя типа объекта), а значения - скалярным типом, функцией или объектом.
	</p>


	<h3>Синтаксис</h3>
<pre class="code-highlight js">
<script type="text/template">
/* свойства */
properties: {
	'TypeName.property': String | Number | Boolean, /* скалярное свойство */
	'TypeName.property': Function,                  /* вычисляемое свойство */
	'TypeName.property': {                          /* вычисляемое свойство с возможностью установки */
		get: Function,
		set: Function
	}
	...
}
</script>
</pre>
	<h3>Правила именования</h3>

	<p>
		Префикс свойства <code>TypeName</code> должен совпадать с <i>именем типа</i>, который задается при построении модели. По соглашению
		имена типов начинаются с заглавной буквы "Т" (от слова Type).
	</p>

	<p>
		Если вычисляемое свойство имеет такое же имя, как и свойство в модели, то оно не добавляется к модели, а <i>заменяет</i>
		свойство модели. Это приведет к тому, что вычисленное значение будет сохранено в модели.
	</p>

	<p>
		Если имя свойства начинается с символов "$" или "_", то оно является внутренними и не участвует
		в обмене данными между клиентом и сервером. Если имя свойства начинается с символов "$$" то его
		изменение не изменяет флажок <a class="code-link" href="/client/data">$dirty</a> для модели.
	</p>

	<h3>Скалярные свойства</h3>
	<p>
		Значением скалярного свойства всегда является примитивный тип JavaScript, такой как, например <code>String</code>, <code>Number</code>
		или <code>Boolean</code>. В модель будет добавлено свойство соответствующего типа.
	</p>


	<h3>Вычисляемые свойства</h3>
	<p>
		Значением вычисляемого свойства является функция, которая будет вычислена при попытке обращения к свойству. Аргумент функции:
		<ul class="params">
			<li><code>this</code> - ссылка на объект, в который добавляется свойство.</li>
		</ul>
		Функция должна вернуть значение свойства.
	</p>
	<p>Функция вызывается только при обращении к свойству. Если обращений нет то функция никогда вызываться не будет.</p>
	<p>Обращения к вычисляемым свойствам могут выполняться многократно и достаточно часто. Никогда не используйте обращение к серверу 
	в коде вычисляемых свойств. Если нужно - используйте кэширование.</p>

	<p class="tip warning">
		<b>Обратите внимание!</b> Не используйте стрелочные функции при определении вычисляемых свойств. Стрелочные функции не имеют
		собственного значения <code>this</code> (они используют родительский контекст), поэтому получить ссылку на объект будет невозможно.
	</p>


	<h3>Вычисляемые свойства с возможностью установки</h3>
	<p>
		В дополнение к функции чтения свойства (геттер) можно задать и функцию установки (сеттер). Эта функция будет вызвана при попытке
		установки значения свойства. Аргументы функции:
		<ul class="params">
			<li><code>this</code> - ссылка на объект, в который добавляется свойство.</li>
			<li><code>value</code> - устанавливаемое значение.</li>
		</ul>
	</p>
	<p>
		Используйте свойства с сеттерами внимательно и осторожно. При этом очень легко получить бесконечную рекурсию.
	</p>

	<h3>Пример</h3>
	<p>
		Пример шаблона документа с вычислением суммы по строке и суммы по документу. 
		Пусть в модели есть документ со строками, в каждой из которых есть цена и количество.
		Нужно автоматически рассчитывать сумму по строке и сумму по документу.

		<pre class="code-highlight js" data-lang="js">
<script type="text/template">
const template = {
	properties: {
		'TRow.Sum'() {return this.Qty * this.Price }, /*сумма по строке */,
		'TDocument.Sum': getDocumentSum /*сумма по документу */
	}
};

function getDocumentSum() {
	return this.Rows.reduce((prev, curr) => prev + curr.Sum, 0);
}
</script>
</pre>

	</p>
</div>