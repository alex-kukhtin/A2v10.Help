<div>
	<!--title:Шаблони. Властивості-->
	<!--keywords:properties;Властивості;-->
	<div class="title">
		<h1>
			Шаблони. Властивості
		</h1>
		<div class="breadcrumb">
			<a href="index">Шаблони</a>
		</div>
	</div>

	<p>
		Розділ властивостей дозволяє додати до елементів моделі додаткові властивості. Они можуть бути як скалярними (рядок, число), так і
		<i>обчислюваними</i>.
	</p>

	<p>
		Обчислювані властивості являють собою потужний механізм, що дозволяє значно спростити реализацію складної
		бізнес-логіки програми. Така властивість являє собою функцію, яка викликається при спробі читання (або встановлення) властивості.
		Результат, що повертається функцією, розглядається як значення властивості.
		При розрахунках функція може звертатися до інших обчислюваних властивостей і т.д.
		Таким чином легко будувати обробники залежних даних без використання моделі подій.
	</p>

	<p>
		Обчислювані властивості можуть як доповнювати, так і заміняти існуючі в моделі статичні властивості.
	</p>

	<p>
		Об'єкт, що описує властивості в шаблоні, є звичайним об'єктом JavaScript.
		Імена властивостей цього об'єкта являють
		собою повне ім'я властивості (включаючи ім'я типу об'єкта), а значення - скалярним типом, функцією або об'єктом.
	</p>


	<h3>Синтаксис</h3>
<pre class="code-highlight js">
	<script type="text/template">
		/* властивості */
		properties: {
		'TypeName.property': String | Number | Boolean, /* скалярна властивість */
		'TypeName.property': Function,                  /* обчислювана властивість */
		'TypeName.property': {                          /* обчислювана властивість з можливість встановлення */
		get: Function,
		set: Function
		}
		...
		}
	</script>
</pre>
	<h3>Правила найменування</h3>

	<p>
		Префікс властивості <code>TypeName</code> повинен співпадати з <i>іменем типу</i>, який задається при побудові моделі. За угодою
		імена типів починаються з заглавної літери "Т" (від слова Type).
	</p>

	<p>
		Якщо обчислювана властивість має таке ж ім'я, як і властивість в моделі, то воно не додається до моделі, а <i>замінює</i>
		властивість моделі. Це призведе до того, що обчислюване значення буде збережене в моделі.
	</p>

	<p>
		Якщо ім'я властивості починається з символів "$" або "_", то оно є внутрішнім і не бере участь
		в обміні даними між клиєнтом і сервером. Якщо ім'я властивості починається з символів "$$" то його
		зміна не встановлює прапорець <a class="code-link" href="/client/data">$dirty</a> для моделі.
	</p>

	<h3>Скалярні властивості</h3>
	<p>
		Значенням скалярної властивості завжди є примітивний тип JavaScript, такий як, наприклад, <code>String</code>, <code>Number</code>
		або <code>Boolean</code>. В модель буде добавлено властивість відповідного типу.
	</p>


	<h3>Обчислювані властивості</h3>
	<p>
		Значенням обчислюваної властивості є функція, яка буде обчислена при спробі звернення до властивості. Аргумент функції:
		<ul class="params">
			<li><code>this</code> - посилання на об'єкт, в який додається властивість.</li>
		</ul>
		Функція повинна повернути значення властивості.
	</p>
	<p>Функція викликається тільки при зверненні до властивості. Якщо звернень нема, то функція ніколи викликатися не буде.</p>
	<p>
		Звернення до обчислюваної властивості можуть виконуватися багаторазово і досить часто. Ніколи не використовуйте звернення до серверу
		в коді обчислюваних властивостей. Якщо потрібно - використовуйте кешування.
	</p>

	<p class="tip warning">
		<b>Зверніть увагу!</b> Не використовуйте стрілочні функції при визначенні обчислюванихх властивостей. Стрілочні функції не мають
		власного значення <code>this</code> (вони використовують батьківський контекст), тому отримати посилання на об`єкт буде неможливо.
	</p>


	<h3>Обчислювані властивості з можливістю встановлення</h3>
	<p>
		На додаток до функції читання властивості (геттер) можна задати і функцію встановлення (сеттер). Ця функція буде викликана при спробі
		встановлення значення властивості. Аргументи функції:
		<ul class="params">
			<li><code>this</code> - посилання на об'єкт, в який додається властивість.</li>
			<li><code>value</code> - начення, що встановлюється.</li>
		</ul>
	</p>
	<p>
		Використовуйте властивості з сеттерами уважно і обережно. При цьому дуже легко отримати нескінченну рекурсію.
	</p>

	<h3>Приклад</h3>
	<p>
		Приклад шаблону документу з обчисленням суми по рядку і суми по документу. 
		Нехай в моделі є документ з рядками, в ккожному з яких є ціна і кількість.
		Потрібно автоматично розрахувати суму по рядку і суму по документу.

		<pre class="code-highlight js" data-lang="js">
<script type="text/template">
const template = {
	properties: {
		'TRow.Sum'() {return this.Qty * this.Price }, /*сума по рядку */,
		'TDocument.Sum': getDocumentSum /*сума по документу */
	}
};

function getDocumentSum() {
	return this.Rows.reduce((prev, curr) => prev + curr.Sum, 0);
}
</script>
</pre>

	</p>
</div>