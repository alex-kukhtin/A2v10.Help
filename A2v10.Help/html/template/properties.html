<div>
	<!--title:Шаблони. Властивості-->
	<!--keywords:properties;Властивості;-->
	<div class="title">
		<h1>
			Шаблони. Властивості
		</h1>
		<div class="breadcrumb">
			<a href="index">Шаблони</a>
		</div>
	</div>

	<p>
		Раздел властивостей дозволяє добавить к елементум моделі додаткові властивості. Они можуть бути як скалярными (строка, число), так и
		<i>вычисляемыми.</i>
	</p>

	<p>
		Вычисляемые властивості являють собою мощный механизм, позволяющий сильно упростить реализацию сложной
		бізнес-логики програми. Такое властивість являє собою функцію, яка викликаєся при спробі чтения (або установки) властивості.
		Возвращаемый функцией результат рассматривается як значення властивості.
		При расчетах функція може звертатися до другим вычисляемым властивостім і т.д.
		Таким образом легко строить обработчики зависимых даних без использования моделі подій.
	</p>

	<p>
		Вычисляемые властивості можуть як дополнять существующие в моделі статичні властивості, так і заменять существующие.
	</p>

	<p>
		Об'єкт, що описує властивості в шаблоне, является звичайним об'єктом JavaScript.
		Імена властивостей цього об'єкта представляют
		собой повне ім'я властивості (включая ім'ятипа об'єкта), а значення - скалярным типом, функцией або об'єктом.
	</p>


	<h3>Синтаксис</h3>
<pre class="code-highlight js">
<script type="text/template">
/* властивості */
properties: {
	'TypeName.property': String | Number | Boolean, /* скалярное властивість */
	'TypeName.property': Function,                  /* вычисляемое властивість */
	'TypeName.property': {                          /* вычисляемое властивість с можливістью установки */
		get: Function,
		set: Function
	}
	...
}
</script>
</pre>
	<h3>Правила именования</h3>

	<p>
		Префикс властивості <code>TypeName</code> повинен совпадать с <i>именем типа</i>, который задається при построении моделі. По соглашению
		імена типов починаються с заглавной буквы "Т" (от слова Type).
	</p>

	<p>
		Якщо вычисляемое властивість має такое же имя, як і властивість в моделі, то оно не додається к моделі, а <i>заменяет</i>
		властивість моделі. Це приведет к тому, що вычисленное значення буде сохранено в моделі.
	</p>

	<p>
		Якщо ім'я властивості починається с символов "$" або "_", то оно является внутренними і не участвует
		в обмене даними между клиентом і сервером. Якщо ім'я властивості починається с символов "$$" то його
		изменение не изменяет флажок <a class="code-link" href="/client/data">$dirty</a> для моделі.
	</p>

	<h3>Скалярные властивості</h3>
	<p>
		Значенням скалярного властивості завжди является примитивный тип JavaScript, такой как, наприклад <code>String</code>, <code>Number</code>
		або <code>Boolean</code>. В модель буде добавлено властивість соответствующйого типа.
	</p>


	<h3>Вычисляемые властивості</h3>
	<p>
		Значенням вычисляемого властивості является функція, яка буде вычислена при спробі обращения к властивості. Аргумент функції:
		<ul class="params">
			<li><code>this</code> - ссылка на об'єкт, в который додається властивість.</li>
		</ul>
		Функція повинна повернути значення властивості.
	</p>
	<p>Функція викликаєся тільки при обращении к властивості. Якщо обращений нет то функція никогда викликатися не буде.</p>
	<p>Обращения к вычисляемым властивостім можуть виконуватися многократно і достаточно часто. Никогда не використовуйте обращение к серверу 
	в коде вычисляемых властивостей. Якщо потрібно - використовуйте кэширование.</p>

	<p class="tip warning">
		<b>Зверніть увагу!</b> Не використовуйте стрелочные функції при определении вычисляемых властивостей. Стрелочные функції не имеют
		собственного значення <code>this</code> (вони используют батьківський контекст), поэтому отримати посилання на об`єкт буде невозможна.
	</p>


	<h3>Вычисляемые властивості с можливістью установки</h3>
	<p>
		В дополнение к функції чтения властивості (геттер) можна задать і функцію установки (сеттер). Ця функція буде викликана при спробі
		установки значення властивості. Аргументи функції:
		<ul class="params">
			<li><code>this</code> - ссылка на об'єкт, в который додається властивість.</li>
			<li><code>value</code> - устанавливаемое значення.</li>
		</ul>
	</p>
	<p>
		Используйте властивості с сеттерами внимательно і осторожно. При этом дуже легко отримати бескінцеву рекурсию.
	</p>

	<h3>Приклад</h3>
	<p>
		Приклад шаблона документа с вычислением суммы по строке і суммы по документу. 
		Нехай в моделі є документ со строками, в каждой з которых є цена і количество.
		Нужно автоматично рассчитывать сумму по строке і сумму по документу.

		<pre class="code-highlight js" data-lang="js">
<script type="text/template">
const template = {
	properties: {
		'TRow.Sum'() {return this.Qty * this.Price }, /*сумма по строке */,
		'TDocument.Sum': getDocumentSum /*сумма по документу */
	}
};

function getDocumentSum() {
	return this.Rows.reduce((prev, curr) => prev + curr.Sum, 0);
}
</script>
</pre>

	</p>
</div>