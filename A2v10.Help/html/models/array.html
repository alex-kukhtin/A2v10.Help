<div>
	<!--title:Модели даних. Массивы-->
	<!--keywords:Массивы;-->
	<div class="title">
		<h1>
			Робота с масивами
		</h1>
		<div class="breadcrumb">
			<a href="index">Модели даних</a>
		</div>
	</div>
	<p>
		Масив може быть як самостоятельным елементом моделі (тогда у нього есть ім'я і он буде отображен в корне моделі),
		так і дочерним елементом какого або другого об'єкта.
	</p>
	<p>Масив визначається типом <code>Array</code> (либо <code>LazyArray</code> для "лінивого" масива) в дескрипторе (первое поле) набора даних.</p>


	<div class="info tip">
		Зверніть увагу! Не следует використовувати масивы со слишком большим количеством елементів.
		Кроме того, що це приводит к падению быстродії, с этим еще і дуже неудобно работать конечному користувачу.
		Для роботи с большими масивами (таблицами) используйте серверную сортировку, фильтрацию і разбиение на страницы.
		<a href="paging">Детальніше...</a>.
		<br />
		<br />
		Рекомендуемый размер масива на клієнті - не более 100 елементів. Максимальный, который не приводит к заметному уменьшению производительности - около 200 елементів.
	</div>

	<h3>Обычные масивы</h3>
	<p>
		Это просто набор даних. Кожна рядок набора буде соответствующим об'єктом масива. Тип об'єкта визначається дескриптором
		набора.
	</p>

	<h5>Приклад</h5>
	<p>

		Нехай маємо фрагмент кода SQL:

<pre class="code-highlight js" data-lang="sql">
<script type="text/template">
select [Agents!TAgent!Array] = null, [Id!!Id] = Id, [Name!!Name] = Name, Code
from dbo.Agents where ....;
</script>
</pre>

		Он сформирует в корне моделі масив <code>Agents</code>. Кожен елемент масива буде иметь тип
		<code>TAgent</code> со наступними властивостями: <code>Id</code>, <code>Name</code>, <code>Code</code>.
	</p>


	<h3>Дочерние масивы</h3>
	<p>
		Дочерний масив завжди является вложенным і являє собою властивість другого об'єкта. Как правило не має имени.
		В родительском об'єкте повинно бути властивість-заполнитель со значенням <code>null</code> і типом елементів дочірнього масива.
		Зверніть увагу, что дочерний набор повинен обрабатываться після основного.
	</p>
	<p>
		Для того, щоб связать масив с родительским об'єктом, в наборе даних обов'язково должно присутствовать
		поле з посиланням на батьківський об`єкт у вигляді <code>[Name!ParentType.PropertyName!ParentId]</code>, где
		<ul class="params">
			<li><b>[Name]</b> - необов'язковое ім'яполя. Може бути пустым.</li>
			<li><b>ParentType.PropertyName</b> - Им'я типа і ім'я властивості батьківського об'єкта, куда буде записан елемент масива.</li>
			<li><b>ParentId</b> - модификатор поля.</li>
		</ul>
	</p>
	<p>
		Связывание работает наступним чином:
		<ol>
			<li>Берется значення поля <code>!ParentId</code>.</li>
			<li>
				В моделі ищется об`єкт с типом <code>ParentType</code>
				с соответствующим идентификатором (само собой разумеется, що цет ідентифікатор повинен быть помечен модификатором <code>!Id</code>).
			</li>
			<li>В найденном об'єкте ищется поле с именем <code>PropertyName</code>. В масив, відповідний этому полю добавляется елемент.</li>
		</ol>
	</p>

	<h5>Приклад</h5>
	<p>

		Нехай маємо фрагмент кода SQL:

<pre class="code-highlight js" data-lang="sql">
<script type="text/template">
/*основної об'єкт*/
select [Document!TDocument!Object] = null, [Id!!Id] = Id, [Date], [Rows!TRow!Array]=null
from dbo.Documents where ....;

/*дочерний масив*/
select [!TRow!Array] = null, [Id!!Id] = Id, [Qty], [Price], [Sum], [!TDocument.Rows!ParentId]=null
from dbo.DocDetails where ....;
</script>
</pre>

		Он сформирует в корне об`єкт <code>Document</code> типа
		<code>TDocument</code> со наступними властивостями: <code>Id</code>, <code>Date</code>, <code>Rows</code>.
		Властивість <code>Rows</code> буде представлять собой масив елементів типа <code>TRow</code> со наступними властивостями:
		<code>Id</code>, <code>Qty</code>, <code>Price</code>, <code>Sum</code>.
	</p>


	<h3>"Ленивые" масивы</h3>

	<p>
		Ленивые (on demand) масивы не добавляются в модель в процессе , а загружаются при первом обращении к властивості.
		Частіше за всі этот механизм використовується у випадку, якщо основная модель являє собою масив, а дочерние масивы
		будуть нужны не завжди, а тільки при попытке их отобразить. Типичный пример - список контрагентов, каждый з которых
		містить пов'язані с ним документы.
	</p>
	<p>
		Ленивые масивы можуть быть тільки дочерними і визначаються модификатором <code>LazyArray</code>.
	</p>
	<div class="tip warning">
		Cледует обратить внимание на то, что структура дочірнього об'єкта (не дані!) повинна быть известна системе
		при начальном построении моделі. Поэтому при использовании "лінивих" масивів, необходимо повернути пустой набор даних,
		который буде определять правильную структуру даних масива. Реальными данными масив заполнится уже в процессе завантаження.
	</div>
	<p>
		Для завантаження лінивого масива буде викликана збережена процедура завантаження моделі з суфіксом, соответствующим имени
		властивості основної моделі. В качестве параметра <code>@Id</code> ей буде передан ідентифікатор основного елементу.
		Она повинна повернути набор, соответствущий описанию масива в основної моделі. Властивість с
		модификатором <code>!ParentId</code> не обов'язково.
	</p>

	<h5>Приклад</h5>
	<p>

		Нехай маємо список контрагенов со списком документов.

<pre class="code-highlight js" data-lang="sql">
<script type="text/template">
<![CDATA[
/*основная процедура*/
create or alter proceduure dbo.[Agent.Index.Load]
@UserId bigint
as
begin
	set nocount on;
	/* основної набор */
	select [Agents!TAgent!Array] = null, [Id!!Id] = Id, [Name!!Name] = Name, [Code]
		[Documents!TDocument!LazyArray] = null /* лінивий масив Documents */
	from dbo.Agents where ....;

	/* структура об'єкта TDocument - пустой набор */
	select [Documents!TDocument!Array] = null, [Id!!Id] = Id, [Date], [Sum], [Memo]
	from dbo.Documents where 0 <> 0;
end
go

/*процедура завантаження лінивого масива. Суффикс Documents відповідає имени властивості в основної моделі.*/
create or alter procedure dbo.[Agent.Documents]
@UserId bigint,
@Id bigint /*идентификтор контрагента, для якого загружается список документов*/
as
begin
	set nocount on;
	select [Documents!TDocument!Array] = null, [Id!!Id] = Id, [Date], [Sum], [Memo]
	from dbo.Documents where [Agent]=@Id and ....;
end
go
]]>
</script>
</pre>

		Он сформирует в корне об`єкт <code>Document</code> типа
		<code>TDocument</code> со наступними властивостями: <code>Id</code>, <code>Date</code>, <code>Rows</code>.
		Властивість <code>Rows</code> буде представлять собой масив елементів типа <code>TRow</code> со наступними властивостями:
		<code>Id</code>, <code>Qty</code>, <code>Price</code>, <code>Sum</code>.
	</p>


	<p>Процедуры завантаження лінивих масивів також можуть имет параметри і використовувати <a href="paging">разбиение на страницы</a>.</p>

	<div class="tip info">
		Зверніть увагу! Є можливість обновить (перезавантажити з базы даних) тільки содержимое лінивого масива 
		без основної моделі. Для цього просто передайте масив в качестве аргумента в команду <a class="code-link" href="/xaml/bind/bindcmd">Refresh (Reload)</a> або в метод
		<a class="code-link" href="/client/controller">$reload</a> контролера.
	</div>
</div>

