<div>
	<!--title:Моделі даних. Массивы-->
	<!--keywords:Массивы;-->
	<div class="title">
		<h1>
			Робота з масивами
		</h1>
		<div class="breadcrumb">
			<a href="index">Моделі даних</a>
		</div>
	</div>
	<p>
		Масив може бути як самостійним елементом моделі (тоді у нього є ім'я і він буде відображений в корені моделі),
		так і дочірнім елементом того чи іншого об'єкта.
	</p>
	<p>Масив визначається типом <code>Array</code> (або <code>LazyArray</code> для "лінивого" масива) в дескрипторі (перше поле) набіру даних.</p>


	<div class="info tip">
		Зверніть увагу! Не слід використовувати масиви з занадто великою кількістю елементів.
		Крім того, що це призводить до зниження швидкодії, з цим ще й дуже незручно працювати кінцевому користувачу.
		Для роботи з великими масивами (таблицями) використовуйте серверне сортування, фільтрацію і розбиття на сторінки.
		<a href="paging">Детальніше...</a>.
		<br />
		<br />
		Рекомендований розмір масиву на клієнті - не більше 100 елементів. Максимальний, який не призводить до помітного падіння швидкодії - близько 200 елементів.
	</div>

	<h3>Звичайні масиви</h3>
	<p>
		Це просто набір даних. Кожен рядок набіру буде відповідним об'єктом масива. Тип об'єкта визначається дескриптором
		набору.
	</p>

	<h5>Приклад</h5>
	<p>

		Нехай маємо фрагмент коду SQL:

<pre class="code-highlight js" data-lang="sql">
<script type="text/template">
select [Agents!TAgent!Array] = null, [Id!!Id] = Id, [Name!!Name] = Name, Code
from dbo.Agents where ....;
</script>
</pre>

		Він сформує в корені моделі масив <code>Agents</code>. Кожен елемент масива буде мати тип
		<code>TAgent</code> з наступними властивостями: <code>Id</code>, <code>Name</code>, <code>Code</code>.
	</p>


	<h3>Дочірні масиви</h3>
	<p>
		Дочірній масив завжди є вкладеним і являє собою властивість іншого об'єкта. Як правило не має імені.
		В батьківському об'єкті повинна бути властивість-заповнювач зі заченнями <code>null</code> і типом елементів дочірнього масива.
		Зверніть увагу, що дочірній набір повинен оброблятися після основного.
	</p>
	<p>
		Для того, щоб зв'язати масив з батьківським об'єктом, в наборі даних обов'язково повинно бути присутнім
		поле з посиланням на батьківський об`єкт у вигляді <code>[Name!ParentType.PropertyName!ParentId]</code>, де 
		<ul class="params">
			<li><b>[Name]</b> - необов'язкове ім'я поля. Може бути пустым.</li>
			<li><b>ParentType.PropertyName</b> - Ім'я типу і ім'я властивості батьківського об'єкта, куди буде записаний елемент масиву.</li>
			<li><b>ParentId</b> - модифікатор поля.</li>
		</ul>
	</p>
	<p>
		Зв'язування працює наступним чином:
		<ol>
			<li>Береться значення поля <code>!ParentId</code>.</li>
			<li>
				В моделі шукається об`єкт з типом <code>ParentType</code>
				з відповідним ідентифікатором (зрозуміло, що цей ідентифікатор повинен бути помічений модифікатором <code>!Id</code>).
			</li>
			<li>В знайденому об'єкті шукається поле з іменем <code>PropertyName</code>. В масив, що відповідає цьому полю, додається елемент.</li>
		</ol>
	</p>

	<h5>Приклад</h5>
	<p>

		Нехай маємо фрагмент коду SQL:

<pre class="code-highlight js" data-lang="sql">
<script type="text/template">
/*Основний об'єкт*/
select [Document!TDocument!Object] = null, [Id!!Id] = Id, [Date], [Rows!TRow!Array]=null
from dbo.Documents where ....;

/*Дочірній масив*/
select [!TRow!Array] = null, [Id!!Id] = Id, [Qty], [Price], [Sum], [!TDocument.Rows!ParentId]=null
from dbo.DocDetails where ....;
</script>
</pre>

		Він сформує в корені об`єкт <code>Document</code> типу
		<code>TDocument</code> з наступними властивостями: <code>Id</code>, <code>Date</code>, <code>Rows</code>.
		Властивість <code>Rows</code> буде являти собою масив елементів типу <code>TRow</code> з наступними властивостями:
		<code>Id</code>, <code>Qty</code>, <code>Price</code>, <code>Sum</code>.
	</p>


	<h3>"Ліниві" масиви</h3>

	<p>
		Ліниві (on demand) масиви не додаються в модель в процесі, а завантажуються при першому зверненні до властивості.
		Частіше за все цей механізм використовується у випадку, якщо основнамодель являє собою масив, а дочірні масиви
		будуть потрібні не завжди, а тільки при спробі їх відобразити. Типовий приклад - перелік контрагентів, кожен з яких
		містить пов'язані з ним документи.
	</p>
	<p>
		Ліниві масиви можуть бути тільки дочірніми і визначаються модифікатором <code>LazyArray</code>.
	</p>
	<div class="tip warning">
		Слід звернути увагу на те, що структура дочірнього об'єкта (не дані!) повинна бути відома системі
		при початковій побудові моделі. Тому при використанні "лінивих" масивів, необхідно повернути пустий набір даних,
		який буде визначати правильну структуру даних масива. Реальными даними масив наповниться вже в процесі завантаження.
	</div>
	<p>
		Для завантаження лінивого масиву буде викликана збережена процедура завантаження моделі з суфіксом, відповідним імені
		властивості основної моделі. В якості параметра <code>@Id</code> їй буде переданий ідентифікатор основного елементу.
		Она повинна повернути набір, що відповідає опису масиву в основній моделі. Властивість з
		модифікатором <code>!ParentId</code> не обов'язкова.
	</p>

	<h5>Приклад</h5>
	<p>

		Нехай маємо перелік контрагентів з переліком документів.

<pre class="code-highlight js" data-lang="sql">
<script type="text/template">
<![CDATA[
/* Основна процедура */
create or alter procedure dbo.[Agent.Index.Load]
@UserId bigint
as
begin
	set nocount on;
	/* Основний набір */
	select [Agents!TAgent!Array] = null, [Id!!Id] = Id, [Name!!Name] = Name, [Code]
		[Documents!TDocument!LazyArray] = null /* лінивий масив Documents */
	from dbo.Agents where ....;

	/* структура об'єкта TDocument - пустий набір */
	select [Documents!TDocument!Array] = null, [Id!!Id] = Id, [Date], [Sum], [Memo]
	from dbo.Documents where 0 <> 0;
end
go

/*процедура завантаження лінивого масива. Суфікс Documents відповідає імені властивості в основній моделі.*/
create or alter procedure dbo.[Agent.Documents]
@UserId bigint,
@Id bigint /*ідентифікатор контрагента, для якого завантажується перелік документів*/
as
begin
	set nocount on;
	select [Documents!TDocument!Array] = null, [Id!!Id] = Id, [Date], [Sum], [Memo]
	from dbo.Documents where [Agent]=@Id and ....;
end
go
]]>
</script>
</pre>

		Він сформує в корені об`єкт <code>Document</code> типу
		<code>TDocument</code> з наступними властивостями: <code>Id</code>, <code>Date</code>, <code>Rows</code>.
		Властивість <code>Rows</code> буде являти собою масив елементів типу <code>TRow</code> з наступними властивостями:
		<code>Id</code>, <code>Qty</code>, <code>Price</code>, <code>Sum</code>.
	</p>


	<p>Процедури завантаження лінивих масивів також можуть мати параметри і використовувати <a href="paging">розбиття на сторінки</a>.</p>

	<div class="tip info">
		Зверніть увагу! Є можливість оновити (перезавантажити з бази даних) тільки вміст лінивого масива 
		без основної моделі. Для цього просто передайте масив в якості аргумента в команду <a class="code-link" href="/xaml/bind/bindcmd">Refresh (Reload)</a> або в метод
		<a class="code-link" href="/client/controller">$reload</a> контролера.
	</div>
</div>

