<div>
	<!--title:Модели данных. Массивы-->
	<!--keywords:Массивы;-->
	<div class="title">
		<h1>
			Работа с массивами
		</h1>
		<div class="breadcrumb">
			<a href="index">Модели данных</a>
		</div>
	</div>
	<p>
		Массив может быть как самостоятельным элементом модели (тогда у него есть имя и он будет отображен в корне модели),
		так и дочерним элементом какого либо другого объекта.
	</p>
	<p>Массив определяется типом <code>Array</code> (либо <code>LazyArray</code> для "ленивого" массива) в дескрипторе (первое поле) набора данных.</p>


	<div class="info tip">
		Обратите внимание! Не следует использовать массивы со слишком большим количеством элементов.
		Кроме того, что это приводит к падению быстродействия, с этим еще и очень неудобно работать конечному пользователю.
		Для работы с большими массивами (таблицами) используйте серверную сортировку, фильтрацию и разбиение на страницы.
		<a href="paging">Подробнее...</a>.
		<br />
		<br />
		Рекомендуемый размер массива на клиенте - не более 100 элементов. Максимальный, который не приводит к заметному уменьшению производительности - около 200 элементов.
	</div>

	<h3>Обычные массивы</h3>
	<p>
		Это просто набор данных. Каждая строка набора будет соответствующим объектом массива. Тип объекта определяется дескриптором
		набора.
	</p>

	<h5>Пример</h5>
	<p>

		Пусть имеется фрагмент кода SQL:

<pre class="code-highlight js" data-lang="sql">
<script type="text/template">
select [Agents!TAgent!Array] = null, [Id!!Id] = Id, [Name!!Name] = Name, Code
from dbo.Agents where ....;
</script>
</pre>

		Он сформирует в корне модели массив <code>Agents</code>. Каждый элемент массива будет иметь тип
		<code>TAgent</code> со следующими свойствами: <code>Id</code>, <code>Name</code>, <code>Code</code>.
	</p>


	<h3>Дочерние массивы</h3>
	<p>
		Дочерний массив всегда является вложенным и представляет собой свойство другого объекта. Как правило не имеет имени.
		В родительском объекте должно быть свойство-заполнитель со значением <code>null</code> и типом элементов дочернего массива.
		Обратите внимание, что дочерний набор должен обрабатываться после основного.
	</p>
	<p>
		Для того, чтобы связать массив с родительским объектом, в наборе данных обязательно должно присутствовать
		поле со ссылкой на родительский объект в виде <code>[Name!ParentType.PropertyName!ParentId]</code>, где
		<ul class="params">
			<li><b>[Name]</b> - необязательное имя поля. Может быть пустым.</li>
			<li><b>ParentType.PropertyName</b> - Имя типа и имя свойства родительского объекта, куда будет записан элемент массива.</li>
			<li><b>ParentId</b> - модификатор поля.</li>
		</ul>
	</p>
	<p>
		Связывание работает следующим образом:
		<ol>
			<li>Берется значение поля <code>!ParentId</code>.</li>
			<li>
				В модели ищется объект с типом <code>ParentType</code>
				с соответствующим идентификатором (само собой разумеется, что этот идентификатор должен быть помечен модификатором <code>!Id</code>).
			</li>
			<li>В найденном объекте ищется поле с именем <code>PropertyName</code>. В массив, соответствующий этому полю добавляется элемент.</li>
		</ol>
	</p>

	<h5>Пример</h5>
	<p>

		Пусть имеется фрагмент кода SQL:

<pre class="code-highlight js" data-lang="sql">
<script type="text/template">
/*основной объект*/
select [Document!TDocument!Object] = null, [Id!!Id] = Id, [Date], [Rows!TRow!Array]=null
from dbo.Documents where ....;

/*дочерний массив*/
select [!TRow!Array] = null, [Id!!Id] = Id, [Qty], [Price], [Sum], [!TDocument.Rows!ParentId]=null
from dbo.DocDetails where ....;
</script>
</pre>

		Он сформирует в корне объект <code>Document</code> типа
		<code>TDocument</code> со следующими свойствами: <code>Id</code>, <code>Date</code>, <code>Rows</code>.
		Свойство <code>Rows</code> будет представлять собой массив элементов типа <code>TRow</code> со следующими свойствами:
		<code>Id</code>, <code>Qty</code>, <code>Price</code>, <code>Sum</code>.
	</p>


	<h3>"Ленивые" массивы</h3>

	<p>
		Ленивые (on demand) массивы не добавляются в модель в процессе , а загружаются при первом обращении к свойству.
		Чаще всего этот механизм используется в случае, если основная модель представляет собой массив, а дочерние массивы
		будут нужны не всегда, а только при попытке их отобразить. Типичный пример - список контрагентов, каждый из которых
		содержит связанные с ним документы.
	</p>
	<p>
		Ленивые массивы могут быть только дочерними и определяются модификатором <code>LazyArray</code>.
	</p>
	<div class="tip warning">
		Cледует обратить внимание на то, что структура дочернего объекта (не данные!) должна быть известна системе
		при начальном построении модели. Поэтому при использовании "ленивых" массивов, необходимо вернуть пустой набор данных,
		который будет определять правильную структуру данных массива. Реальными данными массив заполнится уже в процессе загрузки.
	</div>
	<p>
		Для загрузки ленивого массива будет вызвана хранимая процедура загрузки модели с суффиксом, соответствующим имени
		свойства основной модели. В качестве параметра <code>@Id</code> ей будет передан идентификатор основного элемента.
		Она должна вернуть набор, соответствущий описанию массива в основной модели. Свойство с
		модификатором <code>!ParentId</code> не обязательно.
	</p>

	<h5>Пример</h5>
	<p>

		Пусть имеется список контрагенов со списком документов.

<pre class="code-highlight js" data-lang="sql">
<script type="text/template">
<![CDATA[
/*основная процедура*/
create or alter proceduure dbo.[Agent.Index.Load]
@UserId bigint
as
begin
	set nocount on;
	/* основной набор */
	select [Agents!TAgent!Array] = null, [Id!!Id] = Id, [Name!!Name] = Name, [Code]
		[Documents!TDocument!LazyArray] = null /* ленивый массив Documents */
	from dbo.Agents where ....;

	/* структура объекта TDocument - пустой набор */
	select [Documents!TDocument!Array] = null, [Id!!Id] = Id, [Date], [Sum], [Memo]
	from dbo.Documents where 0 <> 0;
end
go

/*процедура загрузки ленивого массива. Суффикс Documents соответствует имени свойства в основной модели.*/
create or alter procedure dbo.[Agent.Documents]
@UserId bigint,
@Id bigint /*идентификтор контрагента, для которого загружается список документов*/
as
begin
	set nocount on;
	select [Documents!TDocument!Array] = null, [Id!!Id] = Id, [Date], [Sum], [Memo]
	from dbo.Documents where [Agent]=@Id and ....;
end
go
]]>
</script>
</pre>

		Он сформирует в корне объект <code>Document</code> типа
		<code>TDocument</code> со следующими свойствами: <code>Id</code>, <code>Date</code>, <code>Rows</code>.
		Свойство <code>Rows</code> будет представлять собой массив элементов типа <code>TRow</code> со следующими свойствами:
		<code>Id</code>, <code>Qty</code>, <code>Price</code>, <code>Sum</code>.
	</p>


	<p>Процедуры загрузки ленивых массивов также могут имет параметры и использовать <a href="paging">разбиение на страницы</a>.</p>

	<div class="tip info">
		Обратите внимание! Имеется возможность обновить (перезагрузить из базы данных) только содержимое ленивого массива 
		без основной модели. Для этого просто передайте массив в качестве аргумента в команду <a class="code-link" href="/xaml/bind/bindcmd">Refresh (Reload)</a> или в метод
		<a class="code-link" href="/client/controller">$reload</a> контроллера.
	</div>
</div>

