<div>
	<!--title:Обновление моделей-->
	<!--keywords:Update;-->
	<div class="title">
		<h1>
			Обновление моделей
		</h1>
		<div class="breadcrumb">
			<a href="index">Моделі даних</a>
		</div>
	</div>
	<p>
		Зверніть увагу, що модель обновляется целиком за один вызов збереженої процедури.
		Для передчи даних широко використовуються
		<a target="_blank" href="https://docs.microsoft.com/en-us/sql/relational-databases/tables/use-table-valued-parameters-database-engine?view=sql-server-ver15">табличные параметри</a> SQL-сервер.
	</p>
	<p>Обновление моделей виконується наступним чином.</p>
	<p>Сначала клиент надсилає всю модель на сервер.</p>
	<p>
		Система находит ім'ямоделі для соответствующйого дії і викликає збережену процедуру
		з суфіксом <b>.Metadata</b>. Ця процедура повертає декілька набіров с пустым содержимым.
		Імена полей в этих набірах визначають правила, каким образом пребразовывать
		вміст полученной с клієнта моделі в параметри збереженої процедури оновлення моделі.
	</p>
	<p>Система преобразовывает полученые сырые дані в набір таблиц используя полученные метадані.</p>
	<p>Викликається процедура з суфіксом <b>.Update</b> і їй передаються преобразованные таблиці.</p>

	<h3>Правила интерпретации набіров .Metadata</h3>
	<p>Им'я первого поля каждого набіра завжди состоит з трех елементів, разделенных символом '!'.</p>
	<ul>
		<li>Первый елемент - ім'япараметра в процедуре <b>.Update</b>.</li>
		<li>
			Второй елемент - шлях до данным з моделі даних. Не смотря на то, що деякі
			значення можуть являться масивами, шлях всі дорівнює задається через точку.
		</li>
		<li>Третий елемент - завжди значення <b>Metadata</b>.</li>
	</ul>
	<p>
		Остальные поля набіра являють собою властивості в моделі і соответственно поля в табличной переменной.
	</p>
	<p>
		Количество табличных параметрів в процедуре <b>.Update</b> (не считая предопределенных) завжди буде
		дорівнює количеству набіров, які вернула процедура <b>.Metadata</b>.
	</p>

	<h3>Приклад</h3>
	<p>Рассмотрим процедуру оновлення документа. Роботающий приклад <a target="_blank" href="https://github.com/alex-kukhtin/A2v10.Web.Sample/blob/master/App_application/sample/document/model.sql">таблиц і хранмых процедур</a> можна найти на GitHub</p>

	<p>Определим табличные типы</p>
	<pre class="code-highlight js" data-lang="sql">
<script type="text/template">
create type a2v10sample.[Document.TableType] as table(
	Id bigint,
	Kind nvarchar(32),
	[Date] date,
	[No] nvarchar(255),
	[Sum] money,
	[Agent] bigint,
	Memo nvarchar(255)
)
go
create type a2v10sample.[DocDetails.TableType]
as table(
	Id bigint null,
	ParentId bigint null,
	RowNumber int,
	[Qty] float,
	[Price] float,
	[Sum] money,
	Product bigint,
	[Memo] nvarchar(255)
)
go
</script>
</pre>
	<p>
		Первый тип буде соответствовать таблице <b>a2v10sample.Documents</b>, а другої таблице
		<b>a2v10sample.DocDetails</b>.
	</p>

	<p>Процедура отримання метаданих буде мати наступний вид:</p>
	<pre class="code-highlight js" data-lang="sql">
<script type="text/template">
create or alter procedure a2v10sample.[Document.Metadata]
as
begin
	set nocount on;

	declare @Document a2v10sample.[Document.TableType];
	declare @Rows a2v10sample.[DocDetails.TableType];

	select [Document!Document!Metadata] = null, * from @Document;
	select [Rows!Document.Rows!Metadata]=null, * from @Rows;
end
go</script>
</pre>
	<p>
		Она повертає два набіра. Первый набір описує сам документ (в таблице буде завжди одна запись) со всеми нужными полями.
		Ця таблиця буде передана в параметр с именем <b>@Document</b>. Обатите внимание, що в імені
		<b>[Document!Document!Metadata]</b> перше слово <b>Document</b> це ім'япараметра, а второе <b>Document</b> -
		шлях в моделі, откуда надо отримати дані.
	</p>
	<p>
		Второй набір описує таблицю строк. В этой таблице буде стільки же рядків, сколько і в масиві
		<b>Document.Rows</b> исходной моделі. Им'я параметра - <b>@Rows</b>.
	</p>

	<p>Процедура оновлення буде мати наступний вид:</p>
	<pre class="code-highlight js" data-lang="sql">
<script type="text/template">
create or alter procedure a2v10sample.[Document.Update]
@TenantId int = 1,
@UserId bigint,
@Document a2v10sample.[Document.TableType] readonly,
@Rows a2v10sample.[DocDetails.TableType] readonly,
@Kind nvarchar(32)
as
begin
	set nocount on;

	declare @RetId bigint;
	declare @output table(op sysname, id bigint);

	merge a2v10sample.Documents as target
	using @Document as source
	on (target.Id = source.Id)
	when matched then update set 
		target.[Date] = source.[Date],
		target.[No] = source.[No],
		target.Agent = source.Agent,
		target.[Sum] = source.[Sum],
		target.Memo = source.Memo,
		target.DateModified = getdate()
	when not matched by target then
	insert(Kind, [Date], [No], Agent, [Sum], Memo) 
	values (@Kind, [Date], [No], Agent, [Sum], Memo)
	output 
		$action op,
		inserted.Id id
	into @output(op, id);
	select top(1) @RetId = id from @output;

	merge a2v10sample.DocDetails as target
	using @Rows as source
	on (target.Id = source.Id and target.Document = @RetId)
	when matched then update set
			target.RowNo = source.RowNumber,
			target.Product = source.Product,
			target.Qty = source.Qty,
			target.Price = source.Price,
			target.[Sum] = source.[Sum],
			target.Memo = source.Memo
	when not matched by target then insert 
		(Document, RowNo, Qty, Price, [Sum], Product, Memo) values
		(@RetId, RowNumber, Qty, Price, [Sum], Product, Memo)
	when not matched by source and target.Document = @RetId then delete;

	exec a2v10sample.[Document.Load] @UserId, @RetId;
end
go</script>
</pre>

	<p>
		Процедура просто обновляет (або вставляет) документ і його строки используя оператор <b>merge</b>.
		Зверніть увагу, що для отримання идентификатора документа (который нужен для вставки строк)
		використовується псевдотаблица <b>inserted</b>
	</p>

	<h3>Додаткові служебные поля в набірах даних </h3>
	<p>
		При заполнении таблиц даних з моделей в таблиці додаються наступні служебные поля. Якщо вони будуть
		объявлены в табличных типах, то их значення будуть заполнены.
		Эти поля використовуються для связывания дочірніх записей (ведь вони можуть бути новыми і их идентификаторов пока може не быть).
	</p>

	<table class="table-props">
		<thead>
			<tr>
				<th>Им'я</th>
				<th>Тип</th>
				<th>Опис</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td class="prop-name">GUID</td>
				<td>uniqueidentifier</td>
				<td>
					Уникальное значення. Використовується совместно с <b>ParentGUID</b>.
				</td>
			</tr>
			<tr>
				<td class="prop-name">RowNumber</td>
				<td>int</td>
				<td>
					Номер строки в таблице (починаючи з 1).
				</td>
			</tr>
			<tr>
				<td class="prop-name">CurrentKey</td>
				<td>Разные типы</td>
				<td>
					Текущий ключ в таблицях типа <b>Map</b>. Використовується вместе с полем 
					<b>ParentKey</b> дочерней таблиці.
				</td>
			</tr>
			<tr>
				<td class="prop-name">ParentId</td>
				<td>Разные типы</td>
				<td>Ідентифікатор родительской записи. Ідентифікатор - завжди властивість с именем <b>Id</b>.</td>
			</tr>
			<tr>
				<td class="prop-name">ParentGUID</td>
				<td>uniqueidentifier</td>
				<td>Уникальный ідентифікатор родительской записи (властивість с именем <b>GUID</b> з родительской таблиці).</td>
			</tr>
			<tr>
				<td class="prop-name">ParentKey</td>
				<td>Разные типы</td>
				<td>Ключ родительской записи (<b>CurrentKey</b>). Використовується для заполнения таблиц типа <b>Map</b>.</td>
			</tr>
			<tr>
				<td class="prop-name">ParentRowNumber</td>
				<td>int</td>
				<td>Номер строки родительской записи (властивість с именем <b>RowNumber</b> з родительской таблиці).</td>
			</tr>
		</tbody>
	</table>

	<h3>Совет</h3>
	<p>Для того, щоб посмотреть какие дані приходят в збережену процедуру можна використовувати наступний фрагмент кода
	(где @Rows - ім'ятабличного параметра):</p>

	<pre class="code-highlight js" data-lang="sql">
<script type="text/template">
declare @xml nvarchar(max);
set @xml = (select * from @Rows for xml auto);
throw 60000, @xml, 0;
</script>
</pre>

</div>