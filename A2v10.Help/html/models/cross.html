<div>
	<!--title:Перекрестные моделі даних-->
	<!--keywords:Перекрестные моделі даних;-->
	<div class="title">
		<h1>
			Перекрестные моделі даних
		</h1>
		<div class="breadcrumb">
			<a href="index">Моделі даних</a>
		</div>
	</div>
	<p>
		Перекрестная модель даних включает одно або декілька полей,
		які будуть развернуты або в горизонтальный масив елементів (тип <code>CrossArray</code>), або в об`єкт с ключами (тип <code>CrossObject</code>).

		Частіше за всі такі моделі використовуються для
		построения перехресних звітів, в которых количество колонок переменное і визначається полученными данными.

		Це похоже на sql-оператор <b>pivot</b>, но, в отличие від нього, не требуется заранее знать какие колонки будуть включены в результирующий набір.
	</p>
	<p>
		Зверніть увагу, що використовувати перекрестные моделі для об'єктів (не масивів) не має смысла (хотя і не запрещается). Замість этого
		просто використовуйте <code>MapObject</code>.
	</p>

	<p>
		Для перехресних масивів отличия від простых вложенных масивів заключаются в следующем:
		<ul class="std">
			<li>Все перекрестные масиви во всех записях будуть мати одинаковый размер.</li>
			<li>Порядок елементів буде определяться ключем (<code>Key</code>) перекрестного елементу.</li>
			<li>
				Основной масив (той, в якому міститься елементи с перехресними масивами) буде мати додатковое властивість
				<a class="code-link" href="/client/arrayprops">$cross</a>, в якому будуть представлены
				масиви ключів для каждого з перехресних масивів.
			</li>
		</ul>
	</p>

	<p>
		Для перехресних об'єктів логика следующая:
		<ul class="std">
			<li>Все перекрестные об'єкти во всех записях будуть мати одинаковую структуру.</li>
			<li>
				Основной масив (той, в якому міститься елементи с перехресними масивами) буде мати додатковое властивість
				<a class="code-link" href="/client/arrayprops">$cross</a>, в якому будуть представлены
				масиви ключів для каждого з перехресних масивів.
			</li>
		</ul>
	</p>
	<p>Проще всього розібратися с принципами роботи перехресних моделей на примере.</p>

	<h3>Приклад обробки перекрестного масива</h3>
	<p>
		Нехай маємо фрагмент кода SQL:
<pre class="code-highlight js" data-lang="sql">
<script type="text/template">
/* основної набір */
select [RepData!TData!Array] = null, [Id!!Id] = Id, S1, N1, [Cross1!TCross!CrossArray] = null
from ...;

/*перекрестный набір */
select [!TCross!CrossArray] = null, [Key!!Key] = Key, Val, [!TData.Cross1!ParentId] = Id;
from ...;
</script>
</pre>
	</p>

	<p>
		И він повертає наступні дані:
		<table class="sql-table">
			<thead>
				<tr>
					<th>RepData!TData!Array</th>
					<th>Id!!Id</th>
					<th>S1</th>
					<th>N1</th>
					<th>Cross1!TCross!CrossArray</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>null</td>
					<td>10</td>
					<td>Str1</td>
					<td>100</td>
					<td>null</td>
				</tr>
				<tr>
					<td>null</td>
					<td>20</td>
					<td>Str2</td>
					<td>200</td>
					<td>null</td>
				</tr>
			</tbody>
		</table>
		<table class="sql-table">
			<thead>
				<tr>
					<th>!TCross!CrossArray</th>
					<th>Key!!Key</th>
					<th>Val</th>
					<th>!TData.Cross1!ParentId</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>null</td>
					<td>K1</td>
					<td>111</td>
					<td>10</td>
				</tr>
				<tr>
					<td>null</td>
					<td>K2</td>
					<td>222</td>
					<td>20</td>
				</tr>
			</tbody>
		</table>
	</p>

	<p>
		При обработке первого набіра створюється простий масив <code>RepData</code> елементів типа <code>TData</code>. В каждом елементе цього масива буде поле
		<code>Cross1</code>, которое в дальнейшем станет перехресним масивом елементів типа <code>TCross</code>. Зверніть увагу, що в елементах основного обов'язково
		повинен бути присутнім ідентифікатор (поле с типом <code>!Id</code>), для того, щоб наступні набіры даних могли ссылаться на елемент масива.
	</p>
	<p>
		Второй набір обрабатывается наступним чином.
		Сначала шукається поле ссылки на перекрестное поле основного елементу масива (поле с типом <code>!ParentId</code>).
		Тип ссылки указывает на ім'ятипа і ім'я поля через точку. <code>!TData.Cross1!ParentId</code> - поле <code>Cross1</code> в елементе типа <code>TData</code>.
		Вміст перекрестной записи зберігається во внутреннем буфере найденной основної записи.
	</p>
	<p>
		Зверніть увагу, що перекрестный масив обов'язково повинен містити тестовое поле c типом <code>!Key</code>. Оно використовується для внутренней обробки.
		Именно це поле буде содержаться в масиві, который повертається властивістю <code>$cross</code>. Це властивість буде добавлено в сам масив (не елемент!) об'єктів типа
		<code>TData</code>. Обращение к списку ключів буде выглядеть як <code>RepArray.$cross.Cross1.</code>
	</p>

	<p>
		Після обробки всех записей перехресних набіров, система находит объединение всех возможных ключів во всех записях <code>TData</code> і преобразовывает внутренние
		буфреры в масиви. В результаті всі перекрестные масиви будуть мати одинаковую длину.
	</p>
	<p>
		Результирующая модель получится такой:

<pre class="code-highlight js" data-lang="js">
<script type="text/template">
RepData: [
	{
		Id:10,
		S1: "Str1",
		N1: 100,
		Cross1: [
			{Key: 'K1', Val: 111},
			{Key: 'K2', Val: 0 }
		]
	},
	{
		Id: 20,
		S1: "Str2",
		N1: 200,
		Cross1: [
			{Key: 'K1', Val: 0 }
			{Key: 'K2', Val: 222},
		]
	},
	$cross: {
		Cross1: ['K1', 'K2']
	}
]
</script>
</pre>
	</p>

	<h3>Приклад</h3>
	<p>
		Частіше за всі перекрестные моделі використовуються для побудови звітів совместно с таблицями <a class="code-link" href="/xaml/sheet/sheet">Sheet</a>.
		Для того, щоб приклад був более реалистичным, добавим вывод итоговых значений.
		Для вывода перехресних масивів використовується елемент <a class="code-link" href="/xaml/sheet/sheetcellgroup">SheetCellGroup</a>.
	</p>

	<p>
		Шаблон
<pre class="code-highlight js">
<script type="text/template">
const template = {
	properties: {
		/* властивості для всього масива */

		/* объединяемые колонки */
		'TDataArray.$Cross1Span'() {return this.$cross.Cross1.length + 1; },
		/* итоговые значення по перехресним елементум. Повертає масив! */
		'TDataArray.$Cross1Total'() {
			return this.$cross.Cross1.reduce((prevArray, currKey, currIndex) => {
				prevArray.push({ Val: this.reduce((prevTotal, currElem) => prevTotal + currElem.Cross1[currIndex].Val, 0) });
				return prevArray;
			}, []);
		},
		/* общее итоговое значення розділу Cross1 по всем строкам */
		'TDataArray.$GrandTotal'() {
			return this.$Cross1Total.reduce((p, c) => p + c.Val, 0);
		},

		/* властивості для каждого елементу масива */
		/* итоговое значення Cross1 по строке */
		'TData.$Cross1Total'() {return this.Cross1.reduce((p, c) => p + c.Val, 0); }
	}
}
</script>
</pre>


	</p>

	<p>XAML:
<pre class="code-highlight xml">
<script type="text/template">
<![CDATA[
	<Sheet Margin="1rem" GridLines="Both" Compact="True">
		<Sheet.Header>
			<SheetRow Style="Header">
				<SheetCell RowSpan="2">Id</SheetCell>
				<SheetCell RowSpan="2">S1</SheetCell>
				<SheetCell RowSpan="2">N1</SheetCell>
				<SheetCell ColSpan="{Bind RepData.$Cross1Span}">Cross1</SheetCell>
			</SheetRow>
			<SheetRow Style="Header">
				<SheetCellGroup ItemsSource="{Bind RepData.$cross.Cross1}">
					<SheetCell Content="{Bind}" />
				</SheetCellGroup>
				<SheetCell>Total</SheetCell>
			</SheetRow>
			<SheetRow Style="Total">
				<SheetCell ColSpan="3">Total</SheetCell>
				<SheetCellGroup ItemsSource="{Bind RepData.$Cross1Total}">
					<SheetCell Content="{Bind Val}" />
				</SheetCellGroup>
				<SheetCell Content="{Bind RepData.$GrandTotal}"/>
			</SheetRow>
		</Sheet.Header>
		<SheetSection ItemsSource="{Bind RepData}">
			<SheetRow>
				<SheetCell Content="{Bind Id}" />
				<SheetCell Content="{Bind S1}" />
				<SheetCell Content="{Bind N1}" />
				<SheetCellGroup ItemsSource="{Bind Cross1}">
					<SheetCell Content="{Bind Val, DataType=Number, HideZeros=True}" />
				</SheetCellGroup>
				<SheetCell Content="{Bind $Cross1Total}"/>
			</SheetRow>
		</SheetSection>
	</Sheet>
]]>
</script>
</pre>
</p>
	<p>
		Результат:

		<table class="sheet-table">
			<thead>
				<tr>
					<th rowspan="2">Id</th>
					<th rowspan="2">S1</th>
					<th rowspan="2">N1</th>
					<th colspan="3">Cross1</th>
				</tr>
				<tr>
					<th>K1</th>
					<th>K2</th>
					<th>Total</th>
				</tr>
				<tr class="total">
					<th colspan="3">Total</th>
					<th>111</th>
					<th>222</th>
					<th>333</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>10</td>
					<td>Str1</td>
					<td>100</td>
					<td>111</td>
					<td></td>
					<td>111</td>
				</tr>
				<tr>
					<td>20</td>
					<td>Str2</td>
					<td>200</td>
					<td></td>
					<td>222</td>
					<td>222</td>
				</tr>
			</tbody>
		</table>
	</p>
</div>